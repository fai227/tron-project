## 背景，目的

近年，協調型自動運転を用いた，車両の安全性の向上や交通効率の向上が研究されている．協調型自動運転とは，複数の自律走行車両が互いの位置や走行予定を共有し，衝突や混雑を避けるための技術である．  
本製品の目的は，microbit及びMaqueen Plusを利用した協調型自動運転の実現である．リアルタイム性を活用した，時空間グリッド予約システムを導入することにより，複数の自動車が相互干渉を行うことなく走行可能になる．本プログラムでは，各車両が走行予定ルートを他の車両と共有し，時空間上のグリッドを予約することで，交通の効率化と安全性の向上を図る．加えて，マイクロコンピュータの特性を活かし低遅延での処理を実現することにより車両の安全性を確保した．

## 関連内容

### 時空間グリッド予約

我々が所属しているネットワーク情報システム研究室では，時空間グリッド予約の研究を行っている．．時空間グリッド予約は，ダイナミックマップを利用して道路上の空間と時間をグリッドに分割し，車両がそのグリッドを予約することで，各車両の走行計画を調整・共有する仕組みである．このシステムでは，道路を時間的・空間的に区切り，その区画ごとに車両が自分の走行経路を予約する．これにより，各車両が事前にどの区画をどの時間帯に通過するのかを把握し，衝突のリスクを減らすとともに，効率的な交通の流れを実現することが可能となる．研究室では，この時空間グリッド予約を活用した走行調停の研究を進めており，この技術により交通の効率化と安全性の向上が期待されている．以下に時空間グリッド予約の参考図を示す．
本プログラムでは先ほど述べたように，マイクロコンピュータの特性と，時空間グリッド予約の特性を組み合わせることで，車両の安全性を確保する．

## プログラム詳細

全てのプログラムは以下URLに記載している．  
app\_sampleフォルダに以下ソースがある．また，その詳細を記載する．

#### \- app\_main.c

このファイルはプログラム全体のメイン部分を担っており，スタートボタン（AボタンやBボタン）が押されると，サーバーや車両の動作が開始される．プログラムの流れとしては，サーバーを起動して，時空間グリッドを初期化し，無線通信設定や走行プログラムの起動が行われる．

* **Aボタン**: サーバーを起動し，グリッドの初期設定，クロック設定を行い，通信割込設定後に走行プログラムを実行する．  
* **Bボタン**: 車両を起動し，サーバーにIDや侵入時間の問い合わせを行う．

#### \- client.c

クライアントの通信処理を担っている．具体的には，サーバーとの無線通信において，データの送受信やパケットの管理を行う処理を実装した．  
**1．UINT request\_departure\_time\_ms():**  
・サーバーと通信して出発時間をリクエストする関数．  
**2．void reserve\_order(List \*order\_list, UB delay\_until\_departure):**  
・サーバーと通信し，命令リストに予約を追加する関数．サーバーから受け取った命令を元に，Maqueen Plusの移動経路を決定．

#### \- drive.c

移動やラインセンサーを使った交差点の検知など，Maqueen Plusの運転に関する機能を実装した．  
**1．read\_timer\_value:**  
タイマーの現在値を読み取る関数．タイマーの値を取得することで，走行時間の計測が可能になる．
**2.initialize_timer：**
タイマーの初期化，設定を行う関数．
**3．start\_timer:**  
高周波クロックを開始し，タイマーを設定・クリアして，タイマーを開始する関数．この関数を使ってMaqueen Plusの動作時間を測定する準備する．  
**4．stop\_timer:**  
タイマーを停止し，経過した時間を返す関数．ミリ秒（ms）に変換して返す．
**5．is\_intersection:**  
Maqueen Plusのラインセンサーを使って，現在位置が交差点かどうかを検知する関数．この関数は，MAQUEEN\_LINE\_SENSOR\_L2やMAQUEEN\_LINE\_SENSOR\_R2の状態を確認し，交差点に到達したかを判定する．  
 
**6．turn\_left, turn\_right:**  
左折および右折のための関数．モーターの制御を行い，Maqueen Plusが指定された方向に回転するように制御する．交差点での回転動作が完了した後，タイマーで測定した時間を使って，残りの時間を調整する．  
**7．follow\_path:**  
Maqueen Plusが8ビットで指定された動作をする関数．この関数では直進，右左折の動作をする．直進ではline\_tracking()（黒線に沿った走行）を行い，交差点に到達すると，継続時間まで待機する．右左折では，turn_right(),turn_left()の関数を呼び，継続時間まで待機する．前の４ビットが直進もしくは右左折を表し，後の4ビットが継続時間を表す．
**8.start_drive:**
この関数は、Maqueen Plusの走行を開始するメイン関数。サーバーから出発時間を取得し、その時間まで待機したあと経路の予約を行い、送信タスクを起動する。メインループの中で，follow_pathと新しい経路のリクエスト，そして実行済みの指示の削除を行う．
**9. calculate_departure_delay:**
現在のorder_listに含まれる全ての指示の所要時間の合計を計算する関数
**10. process_orders:**
リストの数が一定以下になると，リクエストを送信する関数

#### \- iic.c

I2C通信に必要なレジスタや，I2Cの送受信を制御するためのマクロを定義しており，デバイスとの通信を円滑に行うためのインターフェースを提供する．

#### \- list.c

**1．List \*list\_init():**  
新しいリストを初期化する関数．リストのメモリを動的に確保し，ヘッドとテールを初期化する．  
**2．void list\_unshift(List \*list, void \*data):**  
リストの先頭に要素を追加する．新しい要素をメモリに確保し，ヘッドに追加するロジックを実装した．  
**3．void list\_append(List \*list, void \*data):**  
リストの末尾に要素を追加する関数．リストが空の場合は，ヘッドとテールの両方に新しい要素を追加する．既存の要素がある場合は，テールに新しい要素を追加する．  
**4．void \*list\_shift(List \*list):**  
リストの先頭から要素を取り出して削除する関数．要素がなくなると，リストのヘッドとテールを更新する．  
**5．void \*list\_get(List \*list, UH index):**  
リスト内の特定のインデックスにある要素を取得する関数．インデックスに基づいて，指定された要素を返す．  
**6．void list\_delete(List \*list):**  
リスト全体を削除し，メモリを解放する関数．各要素を順番に削除し，最後にリスト自体を解放する．  
**7．UH list\_length(List \*list):**  
リストの長さを返す関数．現在のリスト内の要素数を取得する．


#### \- maqueen.c

1．maqueen\_init():  
Maqueenの初期化を行う関数．I2Cの初期設定 (iic\_setup) を行い，システムを準備する．  
2．control\_motor():  
指定されたモーター（左，右，または両方）を制御する関数．I2C通信を介して，モーターの進行方向と速度を設定する．  
例: LEFT\_MOTOR の方向と速度を設定する場合，I2Cで LEFT\_DIRECTION レジスタと LEFT\_SPEED レジスタに書き込みを行う．  
3．stop\_all\_motor():  
すべてのモーターを停止する関数．左右のモーターの速度を0に設定し，停止させる．  
4．control\_led():  
指定されたLED（左または右）をオンまたはオフにする関数．LEDの状態（オン/オフ）をI2C通信で設定する．  
5．turn\_off\_all\_led():  
すべてのLEDをオフにする関数．左右のLEDのレジスタに対して，オフ（0）を設定する．  
6．read\_line\_state():  
指定されたラインセンサーがラインを検知しているかどうかを返す関数．I2C通信でセンサーの状態を読み取り，検知結果を1ビットで返す．  
7．read\_line\_value():  
ラインセンサーの値を取得する関数．各センサーの値をI2C通信で読み取り，0から256の範囲の値を返す．


#### \- order.c

**1．is\_forward(Order order):**  
命令が「前進」かどうかを判定．命令の上位4ビットをシフトして確認する．  
**2．is\_backward(Order order):**  
命令が「後退」かどうかを判定．上位4ビットが MOVE\_BACKWARD に一致するかをチェックする．  
**3．is\_left(Order order):**  
命令が「左折」かどうかを判定．上位4ビットが TURN\_LEFT に一致するかを確認する．  
**4．is\_right(Order order):**

命令が「右折」かどうかを判定．上位4ビットが TURN\_RIGHT に一致するかをチェックする．  
**5．get\_order\_duration(Order order):**  
命令の持続時間（秒）を返す．下位4ビットを抽出して，そのビット値を持続時間として返す．  
例: 命令 0x82 の場合，下位4ビットは 0x02 で，持続時間は2秒です．

#### \- server.c

**1．print\_packet():**  
32バイトのパケットを出力する関数．パケット内の各バイトを16進数で表示する．  
**2．radio\_interrupt\_handler():**  
無線通信で発生した割り込み（イベント）を処理するためのハンドラ．割り込みが発生した際に，無線モジュールの状態に応じてデータの受信や送信を制御する．  
EVENTS\_DISABLED: 通信が無効化されたときの処理．  
EVENTS\_END: 通信の終了を検知し，次の通信に備えて RXEN（受信モード）や TXEN（送信モード）を設定する．  
EVENTS\_READY: 通信の準備が整った際に処理を行い，受信か送信を決定する．  
**3．test\_send():**  
無線通信のテストを行う関数．32バイトのパケットを作成し，送信の準備をして送信プロセスを管理する．  
通信の終了やエラーを確認し，送信が完了するまで待機する機能がある．  
**4．start\_server():**  
サーバーを開始する関数．この関数内では，無線通信の設定を行い，サーバーが通信を受け付ける準備をする．

## 実行方法
本プログラムの実行には，micro:bit 4台とMaqueen Plus3台を用意する．micro:bit１台をサーバーとし，残りのmaicro:bit３台をMaqueen Plus３台と組み合わせてクライアント車両とする．操作方法としては，micro:bitのボタン操作により，デバイスをサーバーとして起動するか，クライアント車両として起動するかを選択する．車両を道路環境上の決められた地点にセットし，走行を開始する．
## 結果
複数の車両が協調して走行できるかを確認するために，合計X回の実験を行い，本プログラムの性能を評価した．
1. 動作異常: 実験結果，X回中Y回の動作異常が発生した．特に通信タイムアウトや車両停止が確認された．
2. 衝突回数: 衝突はZ回発生し，安全性においてさらなる改良が必要であると判断された．
3. 目的地までの移動時間: 各車両の目的地までの移動時間の平均はA秒であり，最短B秒，最長C秒となった．
## 考察

## 終わりに
